# Task: CPU 端内联汇编极致优化方案

## 1. 背景与目标
在 SmollM2-135M 这种小参数量模型中，计算延迟主要受限于内存访问和核心计算流水线的调度。现有的 `wide` 库虽然提供了 SIMD 封装，但无法针对特定架构（如 AVX-512 的 32 个寄存器或 NEON 的双发指令）进行精细的手动优化。本项目目标是利用 Rust 1.93 的高性能 `asm!` 支持，重写核心线性代数算子。

## 2. 核心挑战
- **多架构支持**：需要同时覆盖主流的 x86_64 (Intel/AMD) 和 aarch64 (Apple Silicon/Graviton)。
- **性能验证**：汇编并不总是更快。如果不考虑分块（Tiling）和寄存器压力（Registry Pressure），性能可能退化。
- **可维护性**：汇编代码难以调试，需要完善的单元测试保证等价性。

## 3. 优化方案设计

### 3.1 热点函数定位
- `simd_dot_product_ptr`: 负责所有 Linear 层的核心内积。
- `linear_forward_add`: 负责残差连接中的投影累加。
- `rms_norm_inplace`: 负责归一化中的求和。

### 3.2 方案 A：x86_64 AVX2 / AVX-512 优化
- **策略**：利用 FMA3 指令集。
- **汇编设计**：
    - 循环展开：一次处理 4x8=32 个 float (AVX2) 或 4x16=64 个 (AVX-512)。
    - 寄存器分配：使用 8-16 个向量寄存器作为累加器，通过流水线乱序执行隐藏延迟。
- **预期收益**：相比编译器自动生成，减少 15-20% 的循环周转开销。

### 3.3 方案 B：ARM64 (NEON) 优化
- **策略**：利用 NEON 的并行处理能力。
- **汇编设计**：
    - 利用 `fmla.4s` 指令进行向量乘加。
    - 针对 Apple M1/M2/M3 进行针对性的预取优化。
- **预期收益**：在 MacBook 等 ARM 设备上获得显著性能提升。

## 4. 实施计划 (Workflow)

### 第一阶段：基准测试与基线建立
- [ ] 创建 `benches/asm_vs_wide.rs`。
- [ ] 导出各个架构的 `wide` 版本生成汇编供参考 (`cargo asm`)。

### 第二阶段：内联汇编核心开发
- [ ] **Task 2.1**: 实现 `x86_64` AVX2 `asm!` 版内积。
- [ ] **Task 2.2**: 实现 `aarch64` NEON `asm!` 版内积。
- [ ] **Task 2.3**: 开发运行时架构检测（使用 `std::is_x86_feature_detected!`）。

### 第三阶段：性能对比与集成
- [ ] 在 `gllm-kernels` 中引入 `AsmDispatcher`。
- [ ] 运行 `benchmark_llm` 验证 Tokens/s 增益。

## 5. 准入要求
1. 每个汇编内核必须通过 100% 的单元测试对标标量实现。
2. 汇编版性能必须在特定架构上比 `wide` 至少快 10% 才会合并到主路径。

---
**Status**: 方案已确定，待执行。
